---
layout: post
title:  53.最大子序和
date:   2020-5-20 22:30:00 +0000
image: /assets/images/twoscreen.jpg
category：easy
tags:array
---
题目

![题目]({{ "/assets/images/053.png" | relative_url }})


基本思路1：暴力法

使用双层循环，穷举所有的子区间

然后再对子区间内的所有元素求和

时间复杂度O（n^2））

空间复杂度O（1）

![暴力法]({{ "/assets/images/053-1.png" | relative_url }})



基本思路2：动态规划

定义 dp[i] 为以 i 结尾子串的最大值


if（dp[i−1]≥0），dp[i]=dp[i−1]+nums[i]

if（dp[i−1]<0），dp[i]=nums[i]
​	
![动态规划]({{ "/assets/images/053-2.png" | relative_url }})



扩展思路1：动态规划优化

动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans

如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字

如果 sum <= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字

每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果

时间复杂度：O(n)

空间复杂度O（1）

![动态规划优化]({{ "/assets/images/053-3.png" | relative_url }})



扩展思路2：分治法*

分治法是将整个数组切分成几个小组，然后每个小组再切分成几个更小的小组，一直到不能继续切分也就是只剩一个数字为止。每个小组会计算出最优值，汇报给上一级的小组，一级一级汇报，上级拿到下级的汇报找到最大值，得到最终的结果。和归并排序的算法类似，先切分，再合并结果。

这个问题中的关键就是如何切分这些组合才能使每个小组之间不会有重复的组合（有重复的组合意味着有重复的计算量）

首先是切分分组方法，就这个案例中的例子来，我们有一个数组 [-2,1,-3,4,-1,2,1,-5,4] ，一共有 9 个元素，我们 center=(start + end) / 2 这个原则，得到中间元素的索引为 4 ，也就是 -1，拆分成三个组合：

[-2,1,-3,4,-1]以及它的子序列（在-1左边的并且包含它的为一组）

[2,1,-5,4]以及它的子序列（在-1右边不包含它的为一组）

任何包含-1以及它右边元素2的序列为一组（换言之就是包含左边序列的最右边元素以及右边序列最左边元素的序列，比如 [4,-1,2,1]，这样就保证这个组合里面的任何序列都不会和上面两个重复）

以上的三个组合内的序列没有任何的重复的部分，而且一起构成所有子序列的全集，计算出这个三个子集合的最大值，然后取其中的最大值，就是这个问题的答案了。

然而前两个子组合可以用递归来解决，一个函数就搞定，第三个跨中心的组合应该怎么计算最大值呢？

答案就是先计算左边序列里面的包含最右边元素的子序列的最大值，也就是从左边序列的最右边元素向左一个一个累加起来，找出累加过程中每次累加的最大值，就是左边序列的最大值。

同理找出右边序列的最大值，就得到了右边子序列的最大值。左右两边的最大值相加，就是包含这两个元素的子序列的最大值。

在计算过程中，累加和比较的过程是关键操作，一个长度为 n 的数组在递归的每一层都会进行 n 次操作，分治法的递归层级在 logN 级别，所以整体的时间复杂度是 O(nlogn)，在时间效率上不如动态规划的 O(n)O(n) 复杂度。

连续子序列的最大和主要由这三部分子区间里元素的最大和得到：

第 1 部分：子区间 [left, mid]；

第 2 部分：子区间 [mid + 1, right]；

第 3 部分：包含子区间[mid , mid + 1]的子区间，即 nums[mid] 与nums[mid + 1]一定会被选取。

对它们三者求最大值即可。

public int maxSubArrayPosition(int[] nums) {
    
	if (nums == null) {
        
		return 0;
    
	}

    int start = 0;
    
	int end = 0;
    
	int subStart = 0;
    
	int subEnd = 0;
    
	int max = nums[0];    // 全局最大值
    
	int subMax = nums[0];  // 前一个子组合的最大值
    
	for (int i = 1; i < nums.length; i++) {
        
		if (subMax > 0) {
            
			// 前一个子组合最大值大于0，正增益，更新最后元素位置
            
			subMax = subMax + nums[i];
            
			subEnd++;
        
		} else {
            
			// 前一个子组合最大值小于0，抛弃前面的结果，更新当前最大值位置
            
			subMax = nums[i];
            
			subStart = i;
            
			subEnd = i;
       
	   }
       
	   // 计算全局最大值，更新位置，将全局最优解的位置更新
       
	   if (subMax > max) {
        
		max = subMax;
        
		start = subStart;
        
		end = subEnd;
       
	   }
   
   }

	System.out.println("[" + start + ","+ end +"]");
    
	return max;

